<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>常见前端面试手写题</title>
</head>
<body>

<script type="text/javascript">

	const obj = {
	  name: 'xj',
		birth: {
	    year: '1988',
			month: '11',
			info: {
				b: [3, 4]
			}
		}
	}

  /**
   * 深拷贝
   * @param obj
   * @returns {[]|{}|*}
   * let tmp = JSON.stringify(obj)
   * let result = JSON.parse(tmp)
   * 这种方式如果对象中包含函数，函数无法被拷贝下来,
   * 无法拷贝copyObj对象原型链上的属性和方法,
   * 当数据层次很深，可以会栈溢出
   */
	function deepClone(obj) {
	  if (!(typeof obj === 'object' && obj !== null)) {
	    return obj
	  }
		let copy = obj instanceof Array ? [] : {}
		for (let key in obj) {
			if (obj.hasOwnProperty(key)) {
        copy[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]
			}
		}
		return copy
  }
  // let result = deepClone(obj)
  // console.log(result)


  /**
   * 函数柯里化
	 * 指的是一个接受多个参数的函数， 变为一个参数返回一个函数的固定形式，这样便于再次调用(). eg add(1)(2)(3,4)
	 * 函数柯里化是可以给我们带来一下便捷，但是也是会有缺点的，在性能上也会受到影响，
	 * 比如add函数里面需要创建数组去存放每次调用的时候的参数，创建闭包函数这些都会对内存跟速度上会带来花销，
	 * 存取arguments对象通常要比存取命名参数要慢一点。
	 * // 实现一个判断数据类型的方法
		const checktype = function(type, content) {
				return Object.prototype.toString.call(content) === `[object ${type}]`;
		}
		checktype('Number',2); // true
		// 这种方法总是要把type参数传过去，如果写错了就会影响到正确的结果了，可以考虑下如何做到把“Number“做到复用
		const curry = function(type){
				return function(content){
						return Object.prototype.toString.call(content) === `[object ${type}]`;
				}
		}
		const isNumber =  curry('Number');
		isNumber(3) // true 
		// 这里就实现参数的复用了，这样的实现给之后的调用带来了很大的便利
   * @returns {any}
   */
	// function add (x, y) {
	// 	return x + y
	// }
	
	function add() {
		let args = [...arguments]
    // var _args=Array.prototype.slice.call(arguments)
		let fn = function () {
			args.push(...arguments)
			return fn
    }
    fn.toString = function () {
			return args.reduce((prev,next) => prev + next)
    }
    return fn
  }
  // console.log(add(1)(3,5)(4)())

</script>
</body>
</html>
